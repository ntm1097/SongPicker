<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="styles.css" />
    <link rel="icon" href="/Assets/favicon.ico" type="image/x-icon" />
    <title>Clear Praise</title>
  </head>
  <body class="previous__formats">
    <div class="search__filter">
      <div class="search__bar">
        <input class="search__text" type="text" placeholder="Search for songs"/>
      </div>
      <div class="sort__menu">
        <label for="sortMenu">Sort by:</label>
        <select id="sortMenu">
          <option value="date">Most Recent</option>
          <option value="name">Oldest Set</option>
        </select>
      </div>
    </div>
    <div class="use__record" id="weeksContainer"></div>
  </body>
  <script>
    document.addEventListener("DOMContentLoaded", async function () {
      const weeksContainer = document.getElementById("weeksContainer");
      if (!weeksContainer) return;
         
      // Helper function to parse various date formats into a proper Date object
      function parseStoredDate(dateValue) {
        if (!dateValue) return new Date(0); // Very old date for null values

        try {
          // Handle Firestore Timestamp
          if (typeof dateValue === "object" && dateValue.toDate) {
            return dateValue.toDate();
          } else if (typeof dateValue === "object" && dateValue.seconds) {
            return new Date(dateValue.seconds * 1000);
          }

          // Handle string dates
          if (typeof dateValue === "string") {
            // Remove ordinal suffixes (st, nd, rd, th) for parsing
            let cleanedDate = dateValue.replace(/(\d+)(st|nd|rd|th)/g, "$1");

            // Try parsing the cleaned string directly
            let parsedDate = new Date(cleanedDate);

            // If that fails, try some common formats
            if (isNaN(parsedDate.getTime())) {
              // Try "Month Day, Year" format
              const monthDayYear = cleanedDate.match(
                /^(\w+)\s+(\d{1,2}),?\s+(\d{4})$/
              );
              if (monthDayYear) {
                parsedDate = new Date(
                  `${monthDayYear[1]} ${monthDayYear[2]}, ${monthDayYear[3]}`
                );
              }
            }

            // Debug logging
            console.log("Parsing date:", dateValue, "->", parsedDate);

            return isNaN(parsedDate.getTime()) ? new Date(0) : parsedDate;
          }

          // Try direct conversion
          return new Date(dateValue);
        } catch (error) {
          console.error("Date parsing error:", error, "for date:", dateValue);
          return new Date(0); // Return very old date for error cases
        }
      }

      try {
        // Fetch all documents without ordering (we'll sort on client side)
        const snapshot = await db.collection("weeks").get();
        weeksContainer.innerHTML = ""; // Clear any static content

        if (snapshot.empty) {
          weeksContainer.innerHTML = "<p>No previous weeks found.</p>";
          return;
        }

        // Convert to array and add parsed dates for sorting
        const weeks = [];
        snapshot.forEach((doc) => {
          const weekData = doc.data();
          const parsedDate = parseStoredDate(weekData.date);

          weeks.push({
            id: doc.id,
            data: weekData,
            sortDate: parsedDate,
          });
        });

        // Sort by date (most recent first)
        weeks.sort((a, b) => b.sortDate.getTime() - a.sortDate.getTime());

        // Display sorted weeks
        weeks.forEach((week) => {
          const weekDiv = document.createElement("div");
          weekDiv.className = "Previous__week";

          // Format the date for display
          let formattedDate;
          try {
            if (week.sortDate.getTime() === 0) {
              formattedDate = `Unknown Date (${week.data.date})`;
            } else {
              formattedDate = week.sortDate.toLocaleDateString("en-US", {
                month: "long",
                day: "numeric",
                year: "numeric",
              });
            }
          } catch (error) {
            formattedDate = `Date Error (${week.data.date})`;
          }

          weekDiv.innerHTML = `
            <h2 class="record__title">${formattedDate}</h2>
            ${
              week.data.songs && week.data.songs.length > 0
                ? week.data.songs
                    .map(
                      (song, i) =>
                        `<li class="number__order">${i + 1}. ${song}</li>`
                    )
                    .join("")
                : "<p>No songs found</p>"
            }
          `;
          weeksContainer.appendChild(weekDiv);
        });
      } catch (error) {
        weeksContainer.innerHTML = "<p>Error loading previous weeks.</p>";
        console.error("Error fetching weeks:", error);
      }
            // ...existing code...
      document.querySelector(".search__text").addEventListener('keyup', function (event) {
        try {
          const searchTerm = this.value.toLowerCase().trim();
          const allWeekElements = document.querySelectorAll('.Previous__week');
          
          // If search is empty, show all weeks
          if (searchTerm === '') {
            allWeekElements.forEach(weekElement => {
              weekElement.style.display = 'flex';
            });
            return;
          }
          
          // Filter weeks based on search term
          allWeekElements.forEach(weekElement => {
            const songElements = weekElement.querySelectorAll('.number__order');
            let foundMatch = false;
            
            // Check if any song in this week matches the search term
            songElements.forEach(songElement => {
              const songText = songElement.textContent.toLowerCase();
              // Remove the number prefix (e.g., "1. ") to get just the song name
              const songName = songText.replace(/^\d+\.\s*/, '');
              
              if (songName.includes(searchTerm)) {
                foundMatch = true;
              }
            });
            
            // Show or hide the week based on whether a match was found
            if (foundMatch) {
              weekElement.style.display = 'flex';
              
              // Optionally highlight the matching text
              songElements.forEach(songElement => {
                const songText = songElement.textContent;
                const songNamePart = songText.replace(/^(\d+\.\s*)/, '');
                const numberPart = songText.match(/^(\d+\.\s*)/)?.[0] || '';
                
                if (songNamePart.toLowerCase().includes(searchTerm)) {
                  // Create highlighted version
                  const regex = new RegExp(`(${searchTerm})`, 'gi');
                  const highlightedText = songNamePart.replace(regex, '<mark>$1</mark>');
                  songElement.innerHTML = numberPart + highlightedText;
                }
              });
            } else {
              weekElement.style.display = 'none';
            }
          });
          
          // Show message if no results found
          const visibleWeeks = document.querySelectorAll('.Previous__week[style*="flex"]');
          const container = document.getElementById('weeksContainer');
          let noResultsMessage = document.getElementById('no-results-message');
          
          if (visibleWeeks.length === 0 && searchTerm !== '') {
            if (!noResultsMessage) {
              noResultsMessage = document.createElement('p');
              noResultsMessage.id = 'no-results-message';
              noResultsMessage.style.textAlign = 'center';
              noResultsMessage.style.fontSize = '18px';
              noResultsMessage.style.color = '#666';
              noResultsMessage.style.marginTop = '50px';
              container.appendChild(noResultsMessage);
            }
            noResultsMessage.textContent = `No weeks found containing "${this.value}"`;
            noResultsMessage.style.display = 'block';
          } else {
            if (noResultsMessage) {
              noResultsMessage.style.display = 'none';
            }
          }
          
        } catch (error) {
          console.error('Search error:', error);
        }
      });
      
      // Clear search functionality
      document.querySelector(".search__text").addEventListener('input', function(event) {
        // Remove highlights when search is cleared
        if (this.value === '') {
          const allSongElements = document.querySelectorAll('.number__order');
          allSongElements.forEach(songElement => {
            // Remove any HTML highlighting and restore original text
            const originalText = songElement.textContent;
            songElement.innerHTML = originalText;
          });
        }
      });
      
      
    });
  </script>

  <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-app-compat.js"></script>

  <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore-compat.js"></script>
  <script>
    const firebaseConfig = {
      apiKey: "AIzaSyBOX7iUIR-GDnfpY0wQ_oOegJUYOJTM9LE",
      authDomain: "hpbc-songpicker.firebaseapp.com",
      databaseURL: "https://hpbc-songpicker-default-rtdb.firebaseio.com",
      projectId: "hpbc-songpicker",
      storageBucket: "hpbc-songpicker.firebasestorage.app",
      messagingSenderId: "677978452426",
      appId: "1:677978452426:web:b81f46a94cfe0380295f33",
    };

    firebase.initializeApp(firebaseConfig);

    const db = firebase.firestore();
  </script>
  <script src="index.js"></script>
</html>
