<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="styles.css" />
    <link rel="icon" href="/Assets/favicon.ico" type="image/x-icon" />
    <title>Clearly Praise</title>
  </head>
  <body class="previous__formats">
    <div class="search__filter">
      <div class="search__bar">
        <input class="search__text" type="text" />
      </div>
      <div class="sort__menu">
        <label for="sortMenu">Sort by:</label>
        <select id="sortMenu">
          <option value="date">Most Recent</option>
          <option value="name">Oldest Set</option>
        </select>
      </div>
    </div>
    <div class="use__record" id="weeksContainer"></div>
  </body>
  <script>
    document.addEventListener("DOMContentLoaded", async function () {
      const weeksContainer = document.getElementById("weeksContainer");
      if (!weeksContainer) return;

      // Helper function to parse various date formats into a proper Date object
      function parseStoredDate(dateValue) {
        if (!dateValue) return new Date(0); // Very old date for null values

        try {
          // Handle Firestore Timestamp
          if (typeof dateValue === "object" && dateValue.toDate) {
            return dateValue.toDate();
          } else if (typeof dateValue === "object" && dateValue.seconds) {
            return new Date(dateValue.seconds * 1000);
          }

          // Handle string dates
          if (typeof dateValue === "string") {
            // Remove ordinal suffixes (st, nd, rd, th) for parsing
            let cleanedDate = dateValue.replace(/(\d+)(st|nd|rd|th)/g, "$1");

            // Try parsing the cleaned string
            let parsedDate = new Date(cleanedDate);

            // If that fails, try some common formats
            if (isNaN(parsedDate.getTime())) {
              // Try "Month Day, Year" format
              const monthDayYear = cleanedDate.match(
                /^(\w+)\s+(\d{1,2}),?\s+(\d{4})$/
              );
              if (monthDayYear) {
                parsedDate = new Date(
                  `${monthDayYear[1]} ${monthDayYear[2]}, ${monthDayYear[3]}`
                );
              }
            }

            return isNaN(parsedDate.getTime()) ? new Date(0) : parsedDate;
          }

          // Try direct conversion
          return new Date(dateValue);
        } catch (error) {
          console.error("Date parsing error:", error, "for date:", dateValue);
          return new Date(0); // Return very old date for error cases
        }
      }

      try {
        // Fetch all documents without ordering (we'll sort on client side)
        const snapshot = await db.collection("weeks").get();
        weeksContainer.innerHTML = ""; // Clear any static content

        if (snapshot.empty) {
          weeksContainer.innerHTML = "<p>No previous weeks found.</p>";
          return;
        }

        // Convert to array and add parsed dates for sorting
        const weeks = [];
        snapshot.forEach((doc) => {
          const weekData = doc.data();
          const parsedDate = parseStoredDate(weekData.date);

          weeks.push({
            id: doc.id,
            data: weekData,
            sortDate: parsedDate,
          });
        });

        // Sort by date (most recent first)
        weeks.sort((a, b) => b.sortDate.getTime() - a.sortDate.getTime());

        // Display sorted weeks
        weeks.forEach((week) => {
          const weekDiv = document.createElement("div");
          weekDiv.className = "Previous__week";

          // Format the date for display
          let formattedDate;
          try {
            if (week.sortDate.getTime() === 0) {
              formattedDate = `Unknown Date (${week.data.date})`;
            } else {
              formattedDate = week.sortDate.toLocaleDateString("en-US", {
                month: "long",
                day: "numeric",
                year: "numeric",
              });
            }
          } catch (error) {
            formattedDate = `Date Error (${week.data.date})`;
          }

          weekDiv.innerHTML = `
            <h2 class="record__title">${formattedDate}</h2>
            ${
              week.data.songs && week.data.songs.length > 0
                ? week.data.songs
                    .map(
                      (song, i) => `<li class="number__order">${i + 1}. ${song}</li>`
                    )
                    .join("")
                : "<p>No songs found</p>"
            }
          `;
          weeksContainer.appendChild(weekDiv);
        });
      } catch (error) {
        weeksContainer.innerHTML = "<p>Error loading previous weeks.</p>";
        console.error("Error fetching weeks:", error);
      }
    });
  </script>

  <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-app-compat.js"></script>

  <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore-compat.js"></script>
  <script>
    const firebaseConfig = {
      apiKey: "AIzaSyBOX7iUIR-GDnfpY0wQ_oOegJUYOJTM9LE",
      authDomain: "hpbc-songpicker.firebaseapp.com",
      databaseURL: "https://hpbc-songpicker-default-rtdb.firebaseio.com",
      projectId: "hpbc-songpicker",
      storageBucket: "hpbc-songpicker.firebasestorage.app",
      messagingSenderId: "677978452426",
      appId: "1:677978452426:web:b81f46a94cfe0380295f33",
    };

    firebase.initializeApp(firebaseConfig);

    const db = firebase.firestore();
  </script>
  <script src="index.js"></script>
</html>
